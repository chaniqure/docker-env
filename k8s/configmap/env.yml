apiVersion: v1
data:
  mongod.conf: |
    net:
        port: 27017
        bindIp: 0.0.0.0
  nacos.properies: |
    #
    # Copyright 1999-2021 Alibaba Group Holding Ltd.
    #
    # Licensed under the Apache License, Version 2.0 (the "License");
    # you may not use this file except in compliance with the License.
    # You may obtain a copy of the License at
    #
    #      http://www.apache.org/licenses/LICENSE-2.0
    #
    # Unless required by applicable law or agreed to in writing, software
    # distributed under the License is distributed on an "AS IS" BASIS,
    # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    # See the License for the specific language governing permissions and
    # limitations under the License.
    #

    #*************** Spring Boot Related Configurations ***************#
    ### Default web context path:
    server.servlet.contextPath=/nacos
    ### Include message field
    server.error.include-message=ALWAYS
    ### Default web server port:
    server.port=8848

    #*************** Network Related Configurations ***************#
    ### If prefer hostname over ip for Nacos server addresses in cluster.conf:
    # nacos.inetutils.prefer-hostname-over-ip=false

    ### Specify local server's IP:
    # nacos.inetutils.ip-address=


    #*************** Config Module Related Configurations ***************#
    ### If use MySQL as datasource:
    spring.datasource.platform=mysql

    ### Count of DB:
    db.num=1

    ### Connect URL of DB:
    db.url.0=jdbc:mysql://mysql:3306/nacos?characterEncoding=utf8&connectTimeout=1000&socketTimeout=3000&autoReconnect=true&useUnicode=true&useSSL=false&serverTimezone=UTC
    db.user.0=test
    db.password.0=test123456

    ### Connection pool configuration: hikariCP
    db.pool.config.connectionTimeout=30000
    db.pool.config.validationTimeout=10000
    db.pool.config.maximumPoolSize=20
    db.pool.config.minimumIdle=2

    #*************** Naming Module Related Configurations ***************#

    ### If enable data warmup. If set to false, the server would accept request without local data preparation:
    # nacos.naming.data.warmup=true

    ### If enable the instance auto expiration, kind like of health check of instance:
    # nacos.naming.expireInstance=true

    ### Add in 2.0.0
    ### The interval to clean empty service, unit: milliseconds.
    # nacos.naming.clean.empty-service.interval=60000

    ### The expired time to clean empty service, unit: milliseconds.
    # nacos.naming.clean.empty-service.expired-time=60000

    ### The interval to clean expired metadata, unit: milliseconds.
    # nacos.naming.clean.expired-metadata.interval=5000

    ### The expired time to clean metadata, unit: milliseconds.
    # nacos.naming.clean.expired-metadata.expired-time=60000

    ### The delay time before push task to execute from service changed, unit: milliseconds.
    # nacos.naming.push.pushTaskDelay=500

    ### The timeout for push task execute, unit: milliseconds.
    # nacos.naming.push.pushTaskTimeout=5000

    ### The delay time for retrying failed push task, unit: milliseconds.
    # nacos.naming.push.pushTaskRetryDelay=1000

    ### Since 2.0.3
    ### The expired time for inactive client, unit: milliseconds.
    # nacos.naming.client.expired.time=180000

    #*************** CMDB Module Related Configurations ***************#
    ### The interval to dump external CMDB in seconds:
    # nacos.cmdb.dumpTaskInterval=3600

    ### The interval of polling data change event in seconds:
    # nacos.cmdb.eventTaskInterval=10

    ### The interval of loading labels in seconds:
    # nacos.cmdb.labelTaskInterval=300

    ### If turn on data loading task:
    # nacos.cmdb.loadDataAtStart=false


    #*************** Metrics Related Configurations ***************#
    ### Metrics for prometheus
    #management.endpoints.web.exposure.include=*

    ### Metrics for elastic search
    management.metrics.export.elastic.enabled=false
    #management.metrics.export.elastic.host=http://localhost:9200

    ### Metrics for influx
    management.metrics.export.influx.enabled=false
    #management.metrics.export.influx.db=springboot
    #management.metrics.export.influx.uri=http://localhost:8086
    #management.metrics.export.influx.auto-create-db=true
    #management.metrics.export.influx.consistency=one
    #management.metrics.export.influx.compressed=true

    #*************** Access Log Related Configurations ***************#
    ### If turn on the access log:
    server.tomcat.accesslog.enabled=true

    ### The access log pattern:
    server.tomcat.accesslog.pattern=%h %l %u %t "%r" %s %b %D %{User-Agent}i %{Request-Source}i

    ### The directory of access log:
    server.tomcat.basedir=file:.

    #*************** Access Control Related Configurations ***************#
    ### If enable spring security, this option is deprecated in 1.2.0:
    #spring.security.enabled=false

    ### The ignore urls of auth
    nacos.security.ignore.urls=/,/error,/**/*.css,/**/*.js,/**/*.html,/**/*.map,/**/*.svg,/**/*.png,/**/*.ico,/console-ui/public/**,/v1/auth/**,/v1/console/health/**,/actuator/**,/v1/console/server/**

    ### The auth system to use, currently only 'nacos' and 'ldap' is supported:
    nacos.core.auth.system.type=nacos

    ### If turn on auth system:
    nacos.core.auth.enabled=false

    ### Turn on/off caching of auth information. By turning on this switch, the update of auth information would have a 15 seconds delay.
    nacos.core.auth.caching.enabled=true

    ### Since 1.4.1, Turn on/off white auth for user-agent: nacos-server, only for upgrade from old version.
    nacos.core.auth.enable.userAgentAuthWhite=false

    ### Since 1.4.1, worked when nacos.core.auth.enabled=true and nacos.core.auth.enable.userAgentAuthWhite=false.
    ### The two properties is the white list for auth and used by identity the request from other server.
    nacos.core.auth.server.identity.key=serverIdentity
    nacos.core.auth.server.identity.value=security

    ### worked when nacos.core.auth.system.type=nacos
    ### The token expiration in seconds:
    nacos.core.auth.plugin.nacos.token.expire.seconds=18000
    ### The default token:
    nacos.core.auth.plugin.nacos.token.secret.key=SecretKey012345678901234567890123456789012345678901234567890123456789

    ### worked when nacos.core.auth.system.type=ldap，{0} is Placeholder,replace login username
    #nacos.core.auth.ldap.url=ldap://localhost:389
    #nacos.core.auth.ldap.basedc=dc=example,dc=org
    #nacos.core.auth.ldap.userDn=cn=admin,${nacos.core.auth.ldap.basedc}
    #nacos.core.auth.ldap.password=admin
    #nacos.core.auth.ldap.userdn=cn={0},dc=example,dc=org
    #nacos.core.auth.ldap.filter.prefix=uid


    #*************** Istio Related Configurations ***************#
    ### If turn on the MCP server:
    nacos.istio.mcp.server.enabled=false

    #*************** Core Related Configurations ***************#

    ### set the WorkerID manually
    # nacos.core.snowflake.worker-id=

    ### Member-MetaData
    # nacos.core.member.meta.site=
    # nacos.core.member.meta.adweight=
    # nacos.core.member.meta.weight=

    ### MemberLookup
    ### Addressing pattern category, If set, the priority is highest
    # nacos.core.member.lookup.type=[file,address-server]
    ## Set the cluster list with a configuration file or command-line argument
    # nacos.member.list=192.168.16.101:8847?raft_port=8807,192.168.16.101?raft_port=8808,192.168.16.101:8849?raft_port=8809
    ## for AddressServerMemberLookup
    # Maximum number of retries to query the address server upon initialization
    # nacos.core.address-server.retry=5
    ## Server domain name address of [address-server] mode
    # address.server.domain=jmenv.tbsite.net
    ## Server port of [address-server] mode
    # address.server.port=8080
    ## Request address of [address-server] mode
    # address.server.url=/nacos/serverlist

    #*************** JRaft Related Configurations ***************#

    ### Sets the Raft cluster election timeout, default value is 5 second
    # nacos.core.protocol.raft.data.election_timeout_ms=5000
    ### Sets the amount of time the Raft snapshot will execute periodically, default is 30 minute
    # nacos.core.protocol.raft.data.snapshot_interval_secs=30
    ### raft internal worker threads
    # nacos.core.protocol.raft.data.core_thread_num=8
    ### Number of threads required for raft business request processing
    # nacos.core.protocol.raft.data.cli_service_thread_num=4
    ### raft linear read strategy. Safe linear reads are used by default, that is, the Leader tenure is confirmed by heartbeat
    # nacos.core.protocol.raft.data.read_index_type=ReadOnlySafe
    ### rpc request timeout, default 5 seconds
    # nacos.core.protocol.raft.data.rpc_request_timeout_ms=5000

    #*************** Distro Related Configurations ***************#

    ### Distro data sync delay time, when sync task delayed, task will be merged for same data key. Default 1 second.
    # nacos.core.protocol.distro.data.sync.delayMs=1000

    ### Distro data sync timeout for one sync data, default 3 seconds.
    # nacos.core.protocol.distro.data.sync.timeoutMs=3000

    ### Distro data sync retry delay time when sync data failed or timeout, same behavior with delayMs, default 3 seconds.
    # nacos.core.protocol.distro.data.sync.retryDelayMs=3000

    ### Distro data verify interval time, verify synced data whether expired for a interval. Default 5 seconds.
    # nacos.core.protocol.distro.data.verify.intervalMs=5000

    ### Distro data verify timeout for one verify, default 3 seconds.
    # nacos.core.protocol.distro.data.verify.timeoutMs=3000

    ### Distro data load retry delay when load snapshot data failed, default 30 seconds.
    # nacos.core.protocol.distro.data.load.retryDelayMs=30000
  redis.conf: "# Redis配置文件样例\n \n# Note on units: when memory size is needed, it is
    possible to specifiy\n# it in the usual form of 1k 5GB 4M and so forth:\n#\n#
    1k => 1000 bytes\n# 1kb => 1024 bytes\n# 1m => 1000000 bytes\n# 1mb => 1024*1024
    bytes\n# 1g => 1000000000 bytes\n# 1gb => 1024*1024*1024 bytes\n#\n# units are
    case insensitive so 1GB 1Gb 1gB are all the same.\n \n# Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程\n#
    启用守护进程后，Redis会把pid写到一个pidfile中，在/var/run/redis.pid\ndaemonize no\n \n# 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定\n#
    pidfile /var/run/redis.pid\n \n# 指定Redis监听端口，默认端口为6379\n# 如果指定0端口，表示Redis不监听TCP连接\nport
    6379\n \n# 绑定的主机地址\n# 你可以绑定单一接口，如果没有绑定，所有接口都会监听到来的连接\n# bind 127.0.0.1\n \n# Specify
    the path for the unix socket that will be used to listen for\n# incoming connections.
    There is no default, so Redis will not listen\n# on a unix socket when not specified.\n#\n#
    unixsocket /tmp/redis.sock\n# unixsocketperm 755\n \n# 当客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能\ntimeout
    0\n \n# 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose\n# debug
    (很多信息, 对开发／测试比较有用)\n# verbose (many rarely useful info, but not a mess like the
    debug level)\n# notice (moderately verbose, what you want in production probably)\n#
    warning (only very important / critical messages are logged)\nloglevel verbose\n
    \n# 日志记录方式，默认为标准输出，如果配置为redis为守护进程方式运行，而这里又配置为标准输出，则日志将会发送给/dev/null\n# logfile
    /logs/redis.log\n \n# To enable logging to the system logger, just set 'syslog-enabled'
    to yes,\n# and optionally update the other syslog parameters to suit your needs.\n#
    syslog-enabled no\n \n# Specify the syslog identity.\n# syslog-ident redis\n \n#
    Specify the syslog facility.  Must be USER or between LOCAL0-LOCAL7.\n# syslog-facility
    local0\n \n# 设置数据库的数量，默认数据库为0，可以使用select <dbid>命令在连接上指定数据库id\n# dbid是从0到‘databases’-1的数目\n#
    databases 16\n \n################################ SNAPSHOTTING  #################################\n#
    指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合\n# Save the DB on disk:\n#\n#   save <seconds>
    <changes>\n#\n#   Will save the DB if both the given number of seconds and the
    given\n#   number of write operations against the DB occurred.\n#\n#   满足以下条件将会同步数据:\n#
    \  900秒（15分钟）内有1个更改\n#   300秒（5分钟）内有10个更改\n#   60秒内有10000个更改\n#   Note: 可以把所有“save”行注释掉，这样就取消同步操作了\n
    \nsave 900 1\nsave 300 10\nsave 60 10000\n \n# 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大\nrdbcompression
    yes\n \n# 指定本地数据库文件名，默认值为dump.rdb\ndbfilename dump.rdb\n \n# 工作目录.\n# 指定本地数据库存放目录，文件名由上一个dbfilename配置项指定\n#\n#
    Also the Append Only File will be created inside this directory.\n#\n# 注意，这里只能指定一个目录，不能指定文件名\n#
    dir ./\n \n################################# REPLICATION #################################\n
    \n# 主从复制。使用slaveof从 Redis服务器复制一个Redis实例。注意，该配置仅限于当前slave有效\n# so for example it
    is possible to configure the slave to save the DB with a\n# different interval,
    or to listen to another port, and so on.\n# 设置当本机为slav服务时，设置master服务的ip地址及端口，在Redis启动时，它会自动从master进行数据同步\n#
    slaveof <masterip> <masterport>\n \n \n# 当master服务设置了密码保护时，slav服务连接master的密码\n#
    下文的“requirepass”配置项可以指定密码\n# masterauth <master-password>\n \n# When a slave lost
    the connection with the master, or when the replication\n# is still in progress,
    the slave can act in two different ways:\n#\n# 1) if slave-serve-stale-data is
    set to 'yes' (the default) the slave will\n#    still reply to client requests,
    possibly with out of data data, or the\n#    data set may just be empty if this
    is the first synchronization.\n#\n# 2) if slave-serve-stale data is set to 'no'
    the slave will reply with\n#    an error \"SYNC with master in progress\" to all
    the kind of commands\n#    but to INFO and SLAVEOF.\n#\nslave-serve-stale-data
    yes\n \n# Slaves send PINGs to server in a predefined interval. It's possible
    to change\n# this interval with the repl_ping_slave_period option. The default
    value is 10\n# seconds.\n#\n# repl-ping-slave-period 10\n \n# The following option
    sets a timeout for both Bulk transfer I/O timeout and\n# master data or ping response
    timeout. The default value is 60 seconds.\n#\n# It is important to make sure that
    this value is greater than the value\n# specified for repl-ping-slave-period otherwise
    a timeout will be detected\n# every time there is low traffic between the master
    and the slave.\n#\n# repl-timeout 60\n \n################################## SECURITY
    ###################################\n \n# Warning: since Redis is pretty fast
    an outside user can try up to\n# 150k passwords per second against a good box.
    This means that you should\n# use a very strong password otherwise it will be
    very easy to break.\n# 设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过auth <password>命令提供密码，默认关闭\nrequirepass
    test123456\n# Command renaming.\n#\n# It is possilbe to change the name of dangerous
    commands in a shared\n# environment. For instance the CONFIG command may be renamed
    into something\n# of hard to guess so that it will be still available for internal-use\n#
    tools but not available for general clients.\n#\n# Example:\n#\n# rename-command
    CONFIG b840fc02d524045429941cc15f59e41cb7be6c52\n#\n# It is also possilbe to completely
    kill a command renaming it into\n# an empty string:\n#\n# rename-command CONFIG
    \"\"\n \n################################### LIMITS ####################################\n
    \n# 设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，\n# 如果设置maxclients
    0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max Number of clients reached错误信息\n#
    maxclients 128\n \n# Don't use more memory than the specified amount of bytes.\n#
    When the memory limit is reached Redis will try to remove keys with an\n# EXPIRE
    set. It will try to start freeing keys that are going to expire\n# in little time
    and preserve keys with a longer time to live.\n# Redis will also try to remove
    objects from free lists if possible.\n#\n# If all this fails, Redis will start
    to reply with errors to commands\n# that will use more memory, like SET, LPUSH,
    and so on, and will continue\n# to reply to most read-only commands like GET.\n#\n#
    WARNING: maxmemory can be a good idea mainly if you want to use Redis as a\n#
    'state' server or cache, not as a real DB. When Redis is used as a real\n# database
    the memory usage will grow over the weeks, it will be obvious if\n# it is going
    to use too much memory in the long run, and you'll have the time\n# to upgrade.
    With maxmemory after the limit is reached you'll start to get\n# errors for write
    operations, and this may even lead to DB inconsistency.\n# 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，\n#
    当此方法处理后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。\n# Redis新的vm机制，会把Key存放内存，Value会存放在swap区\n#
    maxmemory <bytes>\n \n# MAXMEMORY POLICY: how Redis will select what to remove
    when maxmemory\n# is reached? You can select among five behavior:\n#\n# volatile-lru
    -> remove the key with an expire set using an LRU algorithm\n# allkeys-lru ->
    remove any key accordingly to the LRU algorithm\n# volatile-random -> remove a
    random key with an expire set\n# allkeys->random -> remove a random key, any key\n#
    volatile-ttl -> remove the key with the nearest expire time (minor TTL)\n# noeviction
    -> don't expire at all, just return an error on write operations\n#\n# Note: with
    all the kind of policies, Redis will return an error on write\n#       operations,
    when there are not suitable keys for eviction.\n#\n#       At the date of writing
    this commands are: set setnx setex append\n#       incr decr rpush lpush rpushx
    lpushx linsert lset rpoplpush sadd\n#       sinter sinterstore sunion sunionstore
    sdiff sdiffstore zadd zincrby\n#       zunionstore zinterstore hset hsetnx hmset
    hincrby incrby decrby\n#       getset mset msetnx exec sort\n#\n# The default
    is:\n#\n# maxmemory-policy volatile-lru\n \n# LRU and minimal TTL algorithms are
    not precise algorithms but approximated\n# algorithms (in order to save memory),
    so you can select as well the sample\n# size to check. For instance for default
    Redis will check three keys and\n# pick the one that was used less recently, you
    can change the sample size\n# using the following configuration directive.\n#\n#
    maxmemory-samples 3\n \n############################## APPEND ONLY MODE ###############################\n
    \n#\n# Note that you can have both the async dumps and the append only file if
    you\n# like (you have to comment the \"save\" statements above to disable the
    dumps).\n# Still if append only mode is enabled Redis will load the data from
    the\n# log file at startup ignoring the dump.rdb file.\n# 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。\n#
    因为redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no\n# IMPORTANT: Check the
    BGREWRITEAOF to check how to rewrite the append\n# log file in background when
    it gets too big.\n \nappendonly yes\n \n# 指定更新日志文件名，默认为appendonly.aof\n# appendfilename
    appendonly.aof\n \n# The fsync() call tells the Operating System to actually write
    data on disk\n# instead to wait for more data in the output buffer. Some OS will
    really flush\n# data on disk, some other OS will just try to do it ASAP.\n \n#
    指定更新日志条件，共有3个可选值：\n# no:表示等操作系统进行数据缓存同步到磁盘（快）\n# always:表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）\n#
    everysec:表示每秒同步一次（折衷，默认值）\n \nappendfsync everysec\n# appendfsync no\n \n# When
    the AOF fsync policy is set to always or everysec, and a background\n# saving
    process (a background save or AOF log background rewriting) is\n# performing a
    lot of I/O against the disk, in some Linux configurations\n# Redis may block too
    long on the fsync() call. Note that there is no fix for\n# this currently, as
    even performing fsync in a different thread will block\n# our synchronous write(2)
    call.\n#\n# In order to mitigate this problem it's possible to use the following
    option\n# that will prevent fsync() from being called in the main process while
    a\n# BGSAVE or BGREWRITEAOF is in progress.\n#\n# This means that while another
    child is saving the durability of Redis is\n# the same as \"appendfsync none\",
    that in pratical terms means that it is\n# possible to lost up to 30 seconds of
    log in the worst scenario (with the\n# default Linux settings).\n#\n# If you have
    latency problems turn this to \"yes\". Otherwise leave it as\n# \"no\" that is
    the safest pick from the point of view of durability.\nno-appendfsync-on-rewrite
    no\n \n# Automatic rewrite of the append only file.\n# Redis is able to automatically
    rewrite the log file implicitly calling\n# BGREWRITEAOF when the AOF log size
    will growth by the specified percentage.\n#\n# This is how it works: Redis remembers
    the size of the AOF file after the\n# latest rewrite (or if no rewrite happened
    since the restart, the size of\n# the AOF at startup is used).\n#\n# This base
    size is compared to the current size. If the current size is\n# bigger than the
    specified percentage, the rewrite is triggered. Also\n# you need to specify a
    minimal size for the AOF file to be rewritten, this\n# is useful to avoid rewriting
    the AOF file even if the percentage increase\n# is reached but it is still pretty
    small.\n#\n# Specify a precentage of zero in order to disable the automatic AOF\n#
    rewrite feature.\n \nauto-aof-rewrite-percentage 100\nauto-aof-rewrite-min-size
    64mb\n \n################################## SLOW LOG ###################################\n
    \n# The Redis Slow Log is a system to log queries that exceeded a specified\n#
    execution time. The execution time does not include the I/O operations\n# like
    talking with the client, sending the reply and so forth,\n# but just the time
    needed to actually execute the command (this is the only\n# stage of command execution
    where the thread is blocked and can not serve\n# other requests in the meantime).\n#\n#
    You can configure the slow log with two parameters: one tells Redis\n# what is
    the execution time, in microseconds, to exceed in order for the\n# command to
    get logged, and the other parameter is the length of the\n# slow log. When a new
    command is logged the oldest one is removed from the\n# queue of logged commands.\n
    \n# The following time is expressed in microseconds, so 1000000 is equivalent\n#
    to one second. Note that a negative number disables the slow log, while\n# a value
    of zero forces the logging of every command.\nslowlog-log-slower-than 10000\n
    \n# There is no limit to this length. Just be aware that it will consume memory.\n#
    You can reclaim memory used by the slow log with SLOWLOG RESET.\nslowlog-max-len
    1024\n \n################################ VIRTUAL MEMORY ###############################\n
    \n### WARNING! Virtual Memory is deprecated in Redis 2.4\n### The use of Virtual
    Memory is strongly discouraged.\n \n### WARNING! Virtual Memory is deprecated
    in Redis 2.4\n### The use of Virtual Memory is strongly discouraged.\n \n# Virtual
    Memory allows Redis to work with datasets bigger than the actual\n# amount of
    RAM needed to hold the whole dataset in memory.\n# In order to do so very used
    keys are taken in memory while the other keys\n# are swapped into a swap file,
    similarly to what operating systems do\n# with memory pages.\n# 指定是否启用虚拟内存机制，默认值为no，\n#
    VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中\n# 把vm-enabled设置为yes，根据需要设置好接下来的三个VM参数，就可以启动VM了\n#
    vm-enabled no\n# vm-enabled yes\n \n# This is the path of the Redis swap file.
    As you can guess, swap files\n# can't be shared by different Redis instances,
    so make sure to use a swap\n# file for every redis process you are running. Redis
    will complain if the\n# swap file is already in use.\n#\n# Redis交换文件最好的存储是SSD（固态硬盘）\n#
    虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享\n# *** WARNING *** if you are using
    a shared hosting the default of putting\n# the swap file under /tmp is not secure.
    Create a dir with access granted\n# only to Redis user and configure Redis to
    create the swap file there.\n# vm-swap-file /tmp/redis.swap\n \n# With vm-max-memory
    0 the system will swap everything it can. Not a good\n# default, just specify
    the max amount of RAM you can in bytes, but it's\n# better to leave some margin.
    For instance specify an amount of RAM\n# that's more or less between 60 and 80%
    of your free RAM.\n# 将所有大于vm-max-memory的数据存入虚拟内存，无论vm-max-memory设置多少，所有索引数据都是内存存储的（Redis的索引数据就是keys）\n#
    也就是说当vm-max-memory设置为0的时候，其实是所有value都存在于磁盘。默认值为0\n# vm-max-memory 0\n \n# Redis
    swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的数据大小来设定的。\n#
    建议如果存储很多小对象，page大小最后设置为32或64bytes；如果存储很大的对象，则可以使用更大的page，如果不确定，就使用默认值\n# vm-page-size
    32\n \n# 设置swap文件中的page数量由于页表（一种表示页面空闲或使用的bitmap）是存放在内存中的，在磁盘上每8个pages将消耗1byte的内存\n#
    swap空间总容量为 vm-page-size * vm-pages\n#\n# With the default of 32-bytes memory pages
    and 134217728 pages Redis will\n# use a 4 GB swap file, that will use 16 MB of
    RAM for the page table.\n#\n# It's better to use the smallest acceptable value
    for your application,\n# but the default is large in order to work in most conditions.\n#
    vm-pages 134217728\n \n# Max number of VM I/O threads running at the same time.\n#
    This threads are used to read/write data from/to swap file, since they\n# also
    encode and decode objects from disk to memory or the reverse, a bigger\n# number
    of threads can help with big objects even if they can't help with\n# I/O itself
    as the physical device may not be able to couple with many\n# reads/writes operations
    at the same time.\n# 设置访问swap文件的I/O线程数，最后不要超过机器的核数，如果设置为0，那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟，默认值为4\n#
    vm-max-threads 4\n \n############################### ADVANCED CONFIG ###############################\n
    \n# Hashes are encoded in a special way (much more memory efficient) when they\n#
    have at max a given numer of elements, and the biggest element does not\n# exceed
    a given threshold. You can configure this limits with the following\n# configuration
    directives.\n# 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法\n# hash-max-zipmap-entries
    512\n# hash-max-zipmap-value 64\n \n# Similarly to hashes, small lists are also
    encoded in a special way in order\n# to save a lot of space. The special representation
    is only used when\n# you are under the following limits:\nlist-max-ziplist-entries
    512\nlist-max-ziplist-value 64\n \n# Sets have a special encoding in just one
    case: when a set is composed\n# of just strings that happens to be integers in
    radix 10 in the range\n# of 64 bit signed integers.\n# The following configuration
    setting sets the limit in the size of the\n# set in order to use this special
    memory saving encoding.\nset-max-intset-entries 512\n \n# Similarly to hashes
    and lists, sorted sets are also specially encoded in\n# order to save a lot of
    space. This encoding is only used when the length and\n# elements of a sorted
    set are below the following limits:\nzset-max-ziplist-entries 128\nzset-max-ziplist-value
    64\n \n# Active rehashing uses 1 millisecond every 100 milliseconds of CPU time
    in\n# order to help rehashing the main Redis hash table (the one mapping top-level\n#
    keys to values). The hash table implementation redis uses (see dict.c)\n# performs
    a lazy rehashing: the more operation you run into an hash table\n# that is rhashing,
    the more rehashing \"steps\" are performed, so if the\n# server is idle the rehashing
    is never complete and some more memory is used\n# by the hash table.\n#\n# The
    default is to use this millisecond 10 times every second in order to\n# active
    rehashing the main dictionaries, freeing memory when possible.\n#\n# If unsure:\n#
    use \"activerehashing no\" if you have hard latency requirements and it is\n#
    not a good thing in your environment that Redis can reply form time to time\n#
    to queries with 2 milliseconds delay.\n# 指定是否激活重置哈希，默认为开启\nactiverehashing yes\n
    \n################################## INCLUDES ###################################\n
    \n# 指定包含其他的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各实例又拥有自己的特定配置文件\n# include /path/to/local.conf\n#
    include /path/to/other.conf\n \n \n"
kind: ConfigMap
metadata:
  annotations:
    kubesphere.io/creator: admin
    kubesphere.io/description: 开发环境
  creationTimestamp: "2022-11-23T07:51:07Z"
  name: env
  namespace: user
  resourceVersion: "426551"
  uid: afc83650-33a2-419d-9566-07127ae3ec24
